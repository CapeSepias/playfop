@import Main._

@val version = "0.9-SNAPSHOT"
@val playFopUrl = "file:///home/dan/dmanchester-com-mockup/playfop"
@val versionedPlayFopUrl = playFopUrl + "/" + version

@sect{PlayFOP User Guide}

  @p{@i{This guide applies to PlayFOP @b{@version}}.}

  @p
    PlayFOP is a library for generating PDFs, images, and other types of output in @lnk("Play Framework", "https://www.playframework.com/") applications.
    PlayFOP accepts XSL-FO that an application has generated via a Play @lnk("Twirl", "https://www.playframework.com/documentation/2.6.x/ScalaTemplates") template and processes it with @lnk("Apache FOP", "https://xmlgraphics.apache.org/fop/").

  @sect{Overview}

    @p
      PlayFOP offers:
    @ul
      @li
        A concise invocation syntax. Go from XSL-FO to finished output in as little as a single method call.
      @li
        Transparent caching of expensive Apache FOP objects.
      @li
        Formatters for working with Apache FOP units, and for preserving whitespace in output.
      @li
        Flexible integration into your application via dependency injection.
    @p
      PlayFOP works with Play applications written in Scala or Java.
      It supports Scala 2.11 and 2.12, and Play 2.4 or later.
      (It has been tested with Play 2.4 - 2.6.)

    @p
      PlayFOP's source is @lnk("available on GitHub", "https://github.com/dmanchester/playfop"),
      and a live demo is available @lnk("here", playFopUrl + "/live-demo").

    @sect{Package Structure}

      @p
        PlayFOP's public API is divided into three packages.
        For a given application, package @code{com.dmanchester.playfop.api} is relevant, as well as either @code{com.dmanchester.playfop.api_s} or @code{com.dmanchester.playfop.api_j}, depending on the application's language:

      @table(`class`:="pure-table pure-table-bordered")
        @thead
          @tr
            @th{Package}
            @th{Relevant to Applications in...}
            @th{Documentation}
        @tbody
          @tr
            @td{@code{com.dmanchester.playfop.api}}
            @td{Scala or Java}
            @td{@lnk("Scaladoc", versionedPlayFopUrl + "/scaladoc/index.html")}
          @tr
            @td{@code{com.dmanchester.playfop.api_s}}
            @td{Scala}
            @td{@lnk("Scaladoc", versionedPlayFopUrl + "/scaladoc/index.html")}
          @tr
            @td{@code{com.dmanchester.playfop.api_j}}
            @td{Java}
            @td{@lnk("Javadoc", versionedPlayFopUrl + "/javadoc/index.html")}

  @sect{Using PlayFOP}

    @p
      Add PlayFOP as a dependency to your application's @code{build.sbt}:

    @code
      libraryDependencies ++= Seq(@br
        ...,@br
        "com.dmanchester" %% "playfop" % "@version"@br
      )

    @p
      Then, inject a @code{PlayFop} object that is appropriate for your application's language.

    @sect{Injecting a PlayFop Object Into a Scala Application}

      @p
        In your @code{application.conf}, add:

      @code
        play.modules.enabled += "com.dmanchester.playfop.api_s.PlayFopModule"

      @p
        Then, inject a @code{PlayFop} object into your controller.
        More specifically, and assuming you're using constructor injection, add a @code{PlayFop} class parameter (package @code{com.dmanchester.playfop.api_s}),
        and if you aren't already using the @code{@@Inject} annotation (package @code{javax.inject}), apply it, too.

      @b{Scala Constructor Injection Example, Play 2.6}

      @hl.scala
        class MyController @@Inject() (cc: ControllerComponents, val playFop: PlayFop)
            extends AbstractController(cc) {
          ...

      @b{Scala Constructor Injection Example, Play 2.4 and Play 2.5}

      @hl.scala
        class MyController @@Inject() (val playFop: PlayFop) extends Controller {
          ...

    @sect{Injecting a PlayFop Object Into a Java Application}

      @p
        In your @code{application.conf}, add:

      @code
        play.modules.enabled += "com.dmanchester.playfop.api_j.PlayFopModule"

      @p
        Then, inject a @code{PlayFop} instance into your controller.
        More specifically, and assuming you're using constructor injection, add a @code{PlayFop} field (package @code{com.dmanchester.playfop.api_j}).
        Add a constructor parameter to set it and apply the @code{@@Inject} annotation (package @code{javax.inject}).

      @b{Java Constructor Injection Example}

      @hl.scala
        public class MyController extends Controller {

          private PlayFop playFop;

          @@Inject
          public Application(PlayFop playFop) {
              this.playFop = playFop;
          }

          ...

    @sect{Generating PDFs, Images, and Other Output: Using the PlayFop Object}

      @p
        With the @code{PlayFop} object you inject into your application, you can generate the various kinds of output supported by Apache FOP.

      @p
        At the point in your code where you wish to generate output, invoke the @code{PlayFop} object's @code{process} method.
        The method will return the output as a byte array, which can be returned in an HTTP response, saved to a file, etc.

      @p
        The simplest @code{process} invocation involves two arguments: the XSL-FO output of a Twirl XML template; and an output format/MIME type, typically sourced from @code{org.apache.xmlgraphics.util.MimeConstants}.
        For example, given @code{someTemplate.scala.xml}...

      @hl.xml
        @@(text: String)<?xml version='1.0' encoding='utf-8'?>
        <fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format">
          <fo:layout-master-set>
            <fo:simple-page-master master-name="label">
              <fo:region-body region-name="xsl-region-body"/>
            </fo:simple-page-master>
          </fo:layout-master-set>
          <fo:page-sequence master-reference="label">
            <fo:flow flow-name="xsl-region-body">
              <fo:block font-size="120pt">@@text</fo:block>
            </fo:flow>
          </fo:page-sequence>
        </fo:root>

      @p
        ...you could generate a PNG image as follows:

      @p
        @b{Simple @code{process} Example, Scala}
        @hl.ref(
          wd/'src/'test/'scala/'com/'dmanchester/'playfop/'api_s/'userguide/"UserGuideCodeSamplesSpec.scala",
          start = "val png: Array[Byte] = playFop.process(",
          end = "// END Simple Scala 'process' sample")

      @p
        @b{Simple @code{process} Example, Java}
        @hl.ref(
          wd/'src/'test/'java/'com/'dmanchester/'playfop/'api_j/'userguide/"UserGuideCodeSamplesTest.java",
          start = "byte[] png = playFop.process(",
          end = "// END Simple Java 'process' sample")

      @p
        The resulting PNG (Scala or Java):

      @img(src:="simple-process-example--png.png", style:="border:1px solid #777;")

      @p
        You can also pass to @code{process} either or both of the following options:

        @ul
          @li
            @code{autoDetectFontsForPDF}: Whether, when creating PDF files, Apache FOP should automatically detect operating system fonts (and make them available for PDF files).
          @li
            an @code{FOUserAgent} block: A block of code that modifies the @code{FOUserAgent} that Apache FOP will use.
            Useful for setting a PDF file's subject, author, etc.

      @p
        In Scala applications, you typically supply these options as named arguments.
        The @code{FOUserAgent} block is an @code{FOUserAgent}-accepting function.

      @p
        In Java applications, you supply these items via a builder.
        The @code{FOUserAgent} block is an implementation of the single-method @code{FOUserAgentBlock} interface.

      @p
        The following code examples present the syntax for using @code{autoDetectFontsForPDF} and an @code{FOUserAgent} block.

      @p
        @b{Complex @code{process} Example, Scala}
        @hl.ref(
          wd/'src/'test/'scala/'com/'dmanchester/'playfop/'api_s/'userguide/"UserGuideCodeSamplesSpec.scala",
          start = "val myFOUserAgentBlock = { foUserAgent: FOUserAgent =>",
          end = "// END Complex Scala 'process' sample")

      @p
        @b{Complex @code{process} Example, Java}
        @hl.ref(
          wd/'src/'test/'java/'com/'dmanchester/'playfop/'api_j/'userguide/"UserGuideCodeSamplesTest.java",
          start = "FOUserAgentBlock myFOUserAgentBlock = new FOUserAgentBlock() {",
          end = "// END Complex Java 'process' sample")

      @p
        The resulting PDF (Scala or Java):

      @img(src:="complex-process-example--pdf.png")

    @sect{Applying Apache FOP Units to Values: the Units Class}

      @p
        To apply a numeric value to an XSL-FO element, you generally place the value in an attribute of the element. The value is labeled with the unit of measure (if any), without any intervening space: @code{29.7cm}, @code{9pt}, etc.

      @p
        PlayFOP's @code{Units} class, which is typically used inside a Twirl template, handles this formatting. To use it:

      @ol
        @li
          Create an instance for the desired unit of measure, passing the label and the precision (the number of decimal places to display when formatting a value).

        @li
          Call the instance's @code{format} method, passing the value to be formatted.

      @p
        @b{@code{Units} Example, Inside a Template}

      @hl.xml
        ...beginning of a template that accepts a fontSizeInPoints argument...

        @@import com.dmanchester.playfop.api.Units
        @@pt = @@{new Units("pt", 0)}

        <fo:block-container font-size="@@pt.format(fontSizeInPoints)" ... >

        ...rest of template...

      @p
        @code{Units} instances are thread-safe and may be used across multiple threads.

    @sect{Preserving Whitespace: the Formatters}

      @p
        As XSL-FO is an XML dialect, Apache FOP ignores some kinds of whitespace when processing XSL-FO documents.
        In particular:

      @ul
        @li
          Multiple space characters are collapsed into a single space.

        @li
          Newlines are ignored.

      @p
        PlayFOP's @code{Formatters} object offers methods for preserving both kinds of whitespace.

      @p
        The @code{makeSpacesNonBreaking} method replaces "regular" spaces with no-break ones.
        (No-break spaces are not subject to collapsing.)

      @p
        The @code{makeNewlinesIntoFOBlocks} method takes newline-terminated runs of characters and wraps each one in an @code{<fo:block>} element.
        With the characters wrapped in this fashion, the newlines are preserved in output.

      @p
        Both methods accept a @code{String} argument.
        @code{makeSpacesNonBreaking} returns a @code{String}, while @code{makeNewlinesIntoFOBlocks} returns a a Play Twirl @code{Xml} instance.
        So, if you want both kinds of whitespace preservation, invoke @code{makeSpacesNonBreaking} first and pass its return value to @code{makeNewlinesIntoFOBlocks}.

      @p
        @b{@code{Formatters} Example}

      @p
        Passing the string @code{"H  e  l  l  o\n\n  w  o  r  l  d"} to the following template...

      @hl.xml
        @@(text: String)<?xml version='1.0' encoding='utf-8'?>

        @@import com.dmanchester.playfop.api.Formatters

        <fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format">
          <fo:layout-master-set>
            <fo:simple-page-master master-name="label">
              <fo:region-body region-name="xsl-region-body"/>
            </fo:simple-page-master>
          </fo:layout-master-set>
          <fo:page-sequence master-reference="label">
            <fo:flow flow-name="xsl-region-body">
              <fo:block font-family="Courier" font-size="24pt">@@Formatters.makeNewlinesIntoFOBlocks(Formatters.makeSpacesNonBreaking(text))</fo:block>
            </fo:flow>
          </fo:page-sequence>
        </fo:root>

      @p
        ...and rendering the result as a PDF leads to:

      @img(src:="formatters-example--pdf.png", style:="border:1px solid #777;")

    @sect{Logging}

      @p
        You can configure logging for PlayFOP and Apache FOP via your @code{logback.xml} file.
        PlayFOP logs to the @code{com.dmanchester.playfop} package; Apache FOP, to the @code{org.apache.fop} and @code{logger.org.apache.xmlgraphics} packages.
        So, your logging configuration might include:

      @hl.xml
        <logger name="com.dmanchester.playfop" level="INFO" />
        <logger name="org.apache.fop" level="ERROR" />
        <logger name="org.apache.xmlgraphics" level="ERROR" />

  @sect{Developing PlayFOP}

    @p
      PlayFOP is built with @lnk("sbt", "http://www.scala-sbt.org/").
      It includes a full suite of tests (@lnk("specs2", "http://etorreborre.github.io/specs2/") for Scala code, @lnk("JUnit", "http://junit.org/") for Java code).

    @p
      With sbt's @lnk("cross-building", "http://www.scala-sbt.org/0.13/docs/Cross-Build.html") support, PlayFOP can target Scala 2.11 and 2.12.

    @p
      To begin developing changes to PlayFOP, update @code{build.sbt} and @code{UserGuide.scalatex} with a "@code{...-@lnk("SNAPSHOT", "http://stackoverflow.com/questions/5901378/what-exactly-is-a-maven-snapshot-and-why-do-we-need-it")}" version number.
      (Doing so will ensure locally published JARs and POMs are not undesirably cached by applications that use them.)

    @p
      As you develop your changes, you'll likely make use of a combination of the @code{sbt} commands in the table below.
      By default, commands target Scala 2.12.
      To target both Scala 2.11 and 2.12, prefix a command with "@code{+}".

    @table(`class`:="pure-table pure-table-bordered")
      @thead
        @tr
          @th{Command}
          @th{Description}
      @tbody
        @tr
          @td
            @code{clean}
          @td
            Deletes previous compilation results.
        @tr
          @td
            @code{compile}
          @td
            Compiles the source code.
        @tr
          @td
            @code{test}
          @td
            Runs the tests.
        @tr
          @td
            @code{publishLocal}
          @td
            Compiles the source code and places the resulting JAR and POM file in your local Ivy repository.
        @tr
          @td
            @code{scaladocOnly/doc}
          @td
            Generates the PlayFOP Scaladoc and places it at @code{library/target-scaladoc/scala-2.12/api/index.html}.
        @tr
          @td
            @code{javadocOnly/doc}
          @td
            Generates the PlayFOP Javadoc and places it at @code{library/target-javadoc/scala-2.12/api/index.html}.
        @tr
          @td
            @code{userguide/run}
          @td
            Generates the user guide and places it at @code{library/userguide/target/scalatex/index.html}.

    @p
      When your changes are final and you wish to obtain a distribution, change to a non-snapshot version number in @code{build.sbt} and @code{UserGuide.scalatex} and execute the commands in the table below.
      (Cross-building for Scala 2.11 and 2.12 with "@code{+}" is essential for a complete distribution.)

    @table(`class`:="pure-table pure-table-bordered")
      @thead
        @tr
          @th{Command}
          @th{Description}
      @tbody
        @tr
          @td
            @code{+cleanAll}
          @td
            Deletes the @code{library/dist_...} directories, as well as previous compilation results, previously generated Scaladoc and Javadoc, and the previously generated user guide (if applicable).
        @tr
          @td
            @code{+publishAll}
          @td
            Publishes to each of the @code{library/dist_...} directories a full set of PlayFOP artifacts:
            @ul
              @li{the PlayFOP JAR and POM}
              @li{JARs of the Scaladoc and Javadoc}
              @li{a ZIP of the user guide}
              @li{a JAR of the source code}